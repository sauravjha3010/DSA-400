Number of Common Factors
Question Link :https://leetcode.com/problems/number-of-common-factors/
Problem Statement :

Given two positive integers a and b, return the number of common factors of a and b.

An integer x is a common factor of a and b if x divides both a and b.
Examples:

Example 1:
Input: a = 12, b = 6
Output: 4
Explanation: The common factors of 12 and 6 are 1, 2, 3, 6.

Example 2:
Input: a = 25, b = 30
Output: 2
Explanation: The common factors of 25 and 30 are 1, 5.

Constraints: â€¢ 
1 <= a, b <= 1000
 

ðŸ‘‰Naive approach :-
   Pseudocode:-
 Iterate from 1 to the minimum of a and b.
 For each number, check if it divides both a and b.
 Increment a count if it is a common factor.
 Return the count.
 

ðŸ‘‰Optimal Approach:-
   Pseudocode:
Find the greatest common divisor (GCD) of a and b.
Count the number of divisors of the GCD.
Return the count



// Naive approach
def commonFactorsNaive(a, b):
    count = 0
    for i in range(1, min(a, b) + 1):
        if a % i == 0 and b % i == 0:
            count += 1
    return count


// Optimal Approach
def commonFactorsOptimal(a, b):
    gcd_val = math.gcd(a, b)
    return count_divisors(gcd_val)

def count_divisors(n):
    count = 0
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            if n // i == i:
                count += 1
            else:
                count += 2
    return count

ðŸ‘‰ Time complexity:-
The time complexity of the optimal approach is O(9 * 2^n) because we are trying all possible combinations of digits 
for each position in the number, where n is the length of the number
 

ðŸ‘‰ Space complexity:-
The space complexity is O(2^n) because we are storing all the generated numbers in the result list, which could 
potentially contain up to 2^n numbers, where n is the length of the number.
